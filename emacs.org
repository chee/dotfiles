#+TITLE: ~/dotfiles/emacs.org

* emacs.org
** What is this?
This is my emacs configuration in org-mode using org-babel. It's loaded using =(org-babel-load-file "~/dotfiles/emacs.org")= from my =init.el=. It contains a lot of things inspired (stolen) from places around the on web such as [[http://pages.sachachua.com/.emacs.d/Sacha.html][this one]]. 
** How to Add/Modify 
To add a code block, type =<s= and press =tab=, this adds a code block. Type =emacs-lisp= after =#BEGIN_SRC= to ensure the correct language.
To modify a code block, press =C-c '= to open an emacs-lisp buffer and hack away. Use =eval-buffer= to test the changes, and press =C-c '= again to add the changes to the org file.
** Some good keys to remember
| Key   | Action                                                     |
|-------+------------------------------------------------------------|
| F8    | Open/close neo-tree.                                       |
| C-c ' | Edit code within org-mode code blocks in their native mode |
| C-x u | Open undo-tree                                             |
| C-c h | Open helm-mini to navigate buffers                         |

** Package Setup
Setup the package repositories and startup use-package.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  ;(add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
  ;(add-to-list 'package-archives '("marmalade" . "https://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives
               '("elpy" . "https://jorgenschaefer.github.io/packages/"))
  (package-initialize)

  (require 'use-package)
#+END_SRC
* TODO Things to do 
An on-going list of things I want to change

- [X] move this file to ~/dotfiles/emacs.org
- [ ]fix evil escape keys
- [-] Clean up org-mode stuff [2/3]
  + [X] use use-package
  + [ ] make the bullets prettier
  + [X] make the headers bigger
- [X] magit: [2/2]
  + [X] learn to use
  + [X] configure
- yasnippet: [0/2]
  + [ ] learn to use
  + [ ] configure
- [ ] Configure C#
- [X] add and consolidate more custom keys
  - using =evil-leader=
- [ ] fix eslint/js2

* Emacs
** better defaults
#+BEGIN_SRC emacs-lisp
  (use-package better-defaults
    :ensure t)
#+END_SRC
** dashboard
Load with a nicer looking dashboard than default
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-startup-banner 'logo)
    (setq dashboard-items '((recents . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (agenda . 5))))
#+END_SRC
** keys
=evil-leader= is an easy way to make shortcuts
press the leader key (I like space) and then the key
#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key "c" 'comment-dwim)
    (evil-leader/set-key "g" 'magit-status)
    ;; counsel
    (evil-leader/set-key "f" 'counsel-find-file)
    (evil-leader/set-key "x" 'counsel-M-x)
    (evil-leader/set-key "pf" 'counsel-projectile-find-file)
    (evil-leader/set-key "pd" 'counsel-projectile-find-dir)
    (evil-leader/set-key "pb" 'counsel-projectile-switch-to-buffer)
    (evil-leader/set-key "pp" 'counsel-projectile-switch-project)
    ;; buffers, frames, and windows
    (evil-leader/set-key "bb" 'switch-to-buffer)
    (evil-leader/set-key "bk" 'kill-buffer)
    
    (evil-leader/set-key "RET" 'make-frame-command)
    (evil-leader/set-key "wo" 'split-window-horizontally)
    (evil-leader/set-key "wu" 'split-window-vertically)
    (evil-leader/set-key "wd" 'delete-window)
    (evil-leader/set-key "wh" 'windmove-left)
    (evil-leader/set-key "wj" 'windmove-down)
    (evil-leader/set-key "wk" 'windmove-up)
    (evil-leader/set-key "wl" 'windmove-right)
    ;; bookmarks
    (evil-leader/set-key "rm" 'bookmark-set)
    (evil-leader/set-key "rb" 'bookmark-jump)
    (evil-leader/set-key "rl" 'bookmark-bmenu-list)
    ;; mode specific
    (evil-leader/set-key-for-mode 'org-mode "t" 'org-babel-tangle)
    (evil-leader/set-key-for-mode 'emacs-lisp-mode "eb" 'eval-buffer)
    (evil-leader/set-key-for-mode 'emacs-lisp-mode "el" 'eval-last-sexp)
    (evil-leader/set-key-for-mode 'emacs-lisp-mode "ed" 'eval-defun)
    (evil-leader/set-key-for-mode 'emacs-lisp-mode "er" 'eval-region)
    (evil-leader/set-key-for-mode 'lisp-interaction-mode "eb" 'eval-buffer)
    (evil-leader/set-key-for-mode 'lisp-interaction-mode "el" 'eval-last-sexp)
    (evil-leader/set-key-for-mode 'lisp-interaction-mode "ed" 'eval-defun)
    (evil-leader/set-key-for-mode 'lisp-interaction-mode "er" 'eval-region)
    (evil-leader/set-key-for-mode 'lisp-mode "er" 'eval-region)
    (evil-leader/set-key-for-mode 'lisp-mode "ed" 'eval-defun)

    (evil-leader/set-key-for-mode 'scheme-mode "er" 'geiser-eval-region)
    (evil-leader/set-key-for-mode 'scheme-mode "eR" 'geiser-eval-region-and-go)
    (evil-leader/set-key-for-mode 'scheme-mode "eb" 'geiser-eval-buffer)
    (evil-leader/set-key-for-mode 'scheme-mode "eB" 'geiser-eval-buffer-and-go)
    (evil-leader/set-key-for-mode 'scheme-mode "ed" 'geiser-eval-definition)
    (evil-leader/set-key-for-mode 'scheme-mode "eD" 'geiser-eval-definition-and-go)
    (evil-leader/set-key-for-mode 'scheme-mode "el" 'geiser-eval-eval-sexp))
#+END_SRC

show keyboard shortcuts after pressing a key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (which-key-mode)
    (which-key-setup-minibuffer)
    (which-key-setup-side-window-bottom)
    (setq which-key-idle-delay 0.05)
    (which-key-add-key-based-replacements "SPC w" "windows")
    (which-key-add-key-based-replacements "SPC b" "buffers")
    (which-key-add-key-based-replacements "SPC p" "projects")
    (which-key-add-key-based-replacements "SPC b" "buffers")
    (which-key-add-key-based-replacements "SPC r" "bookmarks")
    (which-key-add-major-mode-key-based-replacements 'scheme-mode "SPC e" "eval")
    (which-key-add-major-mode-key-based-replacements 'lisp-interaction-mode "SPC e" "eval")
    (which-key-add-major-mode-key-based-replacements 'emacs-lispmode "SPC e" "eval"))
#+END_SRC

** evil mode
Because I like like my modal editing. 

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (evil-mode 1))
#+END_SRC

*** TODO fix up the esc keys
#+BEGIN_SRC emacs-lisp
  ;;; esc quits
  ;(define-key evil-normal-state-map [escape] 'keyboard-quit)
  ;(define-key evil-visual-state-map [escape] 'keyboard-quit)
  ;(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  ;(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  ;(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  ;(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  ;(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  ;;;;;;;;;;;;;;;;;
#+END_SRC

** org mode
Trying out org agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list "~/org/agenda/"))
#+END_SRC

This stuff is mostly for making org-mode prettier:
- =org-src-fontify-natively= turns on syntax highlighting for =#+SRC= blocks
- =org-bullets= provides prettier bullets for the header
- =indent-mode= indents each header and text block
- =turn-on-visual-line-mode= is for visual word wrap

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-bullets
    :init
      (setq org-todo-keywords
        '((sequence "TODO" "CURRENT" "|" "DONE")))
    :config
    (setq org-src-fontify-natively t)
    (add-hook 'org-mode-hook 'org-indent-mode)
    (add-hook 'org-mode-hook 'turn-on-visual-line-mode)
    (add-hook 'org-mode-hook
              (lambda ()
                (org-bullets-mode 1)))
    (custom-set-faces
     '(org-level-1 ((t (:inherit outline-1 :height 1.3))))
     '(org-level-2 ((t (:inherit outline-1 :height 1.2))))
     '(org-level-3 ((t (:inherit outline-1 :height 1.1))))
     '(org-level-4 ((t (:inherit outline-1 :height 1.0))))
     '(org-level-5 ((t (:inherit outline-1 :height 1.0))))
     (font-lock-add-keywords 'org-mode
                             '(("^ +\\([-*]\\) "
                                (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))))

  ;; (setq org-todo-keywords
  ;;       '((sequence "TODO" "CURRENT" "|" "DONE")))

  ;; (font-lock-add-keywords 'org-mode
  ;;                         '(("^ +\\([-*]\\) "
  ;;                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;(setq org-hide-emphasis-markers t)
#+END_SRC

I wasn't able to get this to work, but it's supposed to use syntax highlighting for =#+SRC= blocks in html exports
#+BEGIN_SRC emacs-lisp
  ;(use-package htmlize
  ;   :ensure t)
  ;(setq org-src-fontify-natively t)
#+END_SRC

** TODO yasnippet
I should probably use this at some point.
#+BEGIN_SRC emacs-lisp
  ;(use-package yasnippet
  ;  :ensure t
  ;  :init
  ;  (setq yas-snippet-dirs
  ;       '("~/.emacs.d/snippets"))
  ;  :config
  ;  (yas-global-mode 1))
#+END_SRC

** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (add-to-list 'company-backends 'company-tern)
    (global-company-mode))
#+END_SRC
** neotree
Emacs version of NERDTree, press <f8> to open.
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :init
    (setq neo-theme 'ascii)
    :config
    (global-set-key [f8] 'neotree-toggle)
    (add-hook 'neotree-mode-hook
              (lambda ()
                (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
                (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)
                (define-key evil-normal-state-local-map (kbd "q") 'neotree-enter))))
#+END_SRC

** undo-tree
press <C-x u> to use and <q> to quit.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :defer t
    :ensure t
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC

** magit
I should probably learn how to use this.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    ("C-x g" . magit-status))
#+END_SRC

Get evil-mode to play nicely
#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :ensure t)

#+END_SRC

** helm
#+BEGIN_SRC emacs-lisp 
  ;; (use-package helm
  ;;   :ensure t
  ;;   :diminish helm-mode
  ;;   :init
  ;;   (require 'helm-config)
    ;; (helm-mode 1)
    ;; (helm-autoresize-mode 1)
    ;; (setq helm-autoresize-max-height 40)
    ;; :bind
    ;("C-c h" . helm-mini)
    ;; ("C-c a" . helm-apropos)
    ;("M-x" . helm-M-x)
    ;("C-x f" . helm-find-files)
    ;("C-x C-f" . helm-find-files)
    ;; ("<tab>" . helm-execute-persistent-action)
    ;; ("S-<tab>" . helm-select-action)
    ;; )
#+END_SRC

** projectile
Projectile allows some nice things for projects, such as searching for files, managing buffers, etc.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t)
#+END_SRC

** ivy/counsel/swiper
Some nice tools that use the minibuffer.

Replace emacs commands with counsel ones.
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    ("M-x" . counsel-M-x)
    ("C-x C-f" . counsel-find-file)
    ("<f1> f" . counsel-describe-function)
    ("<f1> v" . counsel-describe-variable)
    ("<f1> l" . counsel-find-library)
    ("<f2> i" . counsel-info-lookup-symbol)
    ("<f2> u" . counsel-unicode-char)
    ("C-c g" . counsel-git)
    ("C-c j" . counsel-git-grep)
    ("C-c k" . counsel-ag)
    ("C-x l" . counsel-locate)
    ("C-S-o" . counsel-rhythmbox)
    ("C-S-r" . counsel-expression-history))
#+END_SRC

Replace emacs search and evil search with swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind
    ("C-s" . swiper)
    :config
    (define-key evil-normal-state-map (kbd "/") 'swiper))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :init
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-height 20)
    :bind
    ("<f6>" . ivy-resume))

  (use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-on))
#+END_SRC
** random things
Change "yes or no" to "y or n"
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** rainbow delimiters
Add rainbow delimiters in all programming language modes
#+BEGIN_SRC emacs-lisp 
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** dashboard
#+BEGIN_SRC emacs-lisp
  ;; (setq inhibit-startup-screen t)

  ;; (use-package dashboard
  ;;   :ensure t
  ;;   :config
  ;;   (dashboard-setup-startup-hook))

  ;; (setq initial-buffer-choice "\*dashboard\*")
#+END_SRC

** windmove
#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings)
#+END_SRC

* Languages
** smartparens
autocomplete for brackets
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t)
#+END_SRC
** flycheck
=my/use-eslint-from-node-modules= function from: https://emacs.stackexchange.com/questions/21205/flycheck-with-file-relative-eslint-executable
#+BEGIN_SRC emacs-lisp
  ;; look for the eslint executable
  (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))

  (use-package flycheck
    :ensure t
    :config
    (global-flycheck-mode)
    (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
    (flycheck-add-mode 'javascript-eslint 'javascript-mode))
#+END_SRC

** Python
[[https://github.com/jorgenschaefer/elpy][elpy]] is an "Emacs Lisp Python Environment"
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :config
    (elpy-enable))
#+END_SRC
Jedi is used for autocompletion.
#+BEGIN_SRC emacs-lisp
  ;; (use-package jedi
  ;;   :ensure t
  ;;   :init
  ;;   (setq jedi:complete-on-dot t)
  ;;   :config
  ;;   (add-hook 'python-mode-hook 'jedi:setup))
    ;;(setq jedi:tooltip-show t)
    ;;(setq jedi:tooltip-method '(popup)))
#+END_SRC

** C#
#+BEGIN_SRC emacs-lisp
  ;; (use-package csharp-mode
  ;;   :ensure t
  ;;   :init
  ;;   ;(autoload 'csharp-mode "csharp-mode" "Major mode for editing C# code." t)
  ;;   (setq auto-mode-alist
  ;;      (append '(("\\.cs$" . csharp-mode)) auto-mode-alist)))
#+END_SRC
Omnisharp should load after a csharp file is loaded
#+BEGIN_SRC emacs-lisp
  ;; (use-package omnisharp
  ;;   :ensure t
  ;;   :init
  ;;   (setq omnisharp-server-executable-path "~/omnisharp-server/OmniSharp/bin/Debug/OmniSharp.exe")
  ;;   :config
  ;;  (add-hook 'csharp-mode-hook 'omnisharp-mode))
#+END_SRC
omnisharp evil-mode keys...
taken from: https://github.com/OmniSharp/omnisharp-emacs/blob/master/example-config-for-evil-mode.el
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'insert omnisharp-mode-map (kbd "M-.") 'omnisharp-auto-complete)
  (evil-define-key 'normal omnisharp-mode-map (kbd "<f12>") 'omnisharp-go-to-definition)
  (evil-define-key 'normal omnisharp-mode-map (kbd "g u") 'omnisharp-find-usages)
  (evil-define-key 'normal omnisharp-mode-map (kbd "g I") 'omnisharp-find-implementations) ; g i is taken
  (evil-define-key 'normal omnisharp-mode-map (kbd "g o") 'omnisharp-go-to-definition)
  (evil-define-key 'normal omnisharp-mode-map (kbd "g r") 'omnisharp-run-code-action-refactoring)
  (evil-define-key 'normal omnisharp-mode-map (kbd "g f") 'omnisharp-fix-code-issue-at-point)
  (evil-define-key 'normal omnisharp-mode-map (kbd "g F") 'omnisharp-fix-usings)
  (evil-define-key 'normal omnisharp-mode-map (kbd "g R") 'omnisharp-rename)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", i") 'omnisharp-current-type-information)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", I") 'omnisharp-current-type-documentation)
  (evil-define-key 'insert omnisharp-mode-map (kbd ".") 'omnisharp-add-dot-and-auto-complete)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", n t") 'omnisharp-navigate-to-current-file-member)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", n s") 'omnisharp-navigate-to-solution-member)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", n f") 'omnisharp-navigate-to-solution-file-then-file-member)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", n F") 'omnisharp-navigate-to-solution-file)
  (evil-define-key 'normal omnisharp-mode-map (kbd ", n r") 'omnisharp-navigate-to-region)
  (evil-define-key 'normal omnisharp-mode-map (kbd "<f12>") 'omnisharp-show-last-auto-complete-result)
  (evil-define-key 'insert omnisharp-mode-map (kbd "<f12>") 'omnisharp-show-last-auto-complete-result)
  (evil-define-key 'normal omnisharp-mode-map (kbd ",.") 'omnisharp-show-overloads-at-point)
  (evil-define-key 'normal omnisharp-mode-map (kbd ",rl") 'recompile)

  (evil-define-key 'normal omnisharp-mode-map (kbd ",rt")
    (lambda() (interactive) (omnisharp-unit-test "single")))

  (evil-define-key 'normal omnisharp-mode-map
    (kbd ",rf")
    (lambda() (interactive) (omnisharp-unit-test "fixture")))

  (evil-define-key 'normal omnisharp-mode-map
    (kbd ",ra")
    (lambda() (interactive) (omnisharp-unit-test "all")))

  ;; Speed up auto-complete on mono drastically. This comes with the
  ;; downside that documentation is impossible to fetch.
  (setq omnisharp-auto-complete-want-documentation nil)
#+END_SRC

** C
**** TODO set this up using use-package
Example taken from [[https://www.emacswiki.org/emacs/IndentingC][EmacsWIki: Indenting C]]
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux"
        c-basic-offset 4)
#+END_SRC
** Lisp
- =show-paren-mode= highlights matching parentheses 
- =paredit= inserts matching parentheses, among other things..
#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)

  (use-package paredit
    :ensure t
    :init
    (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook #'enable-paredit-mode)
    (add-hook 'geiser-repl-mode-hook #'enable-paredit-mode))


  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

=geiser= provides a nice repl for *scheme* and other things
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :config
    (setq geiser-active-implementations '(guile mit racket)))
#+END_SRC

Using this to mess with stumpwm right now.
#+BEGIN_SRC emacs-lisp
  ;; (use-package slime
  ;;   :ensure t
  ;;   :init
  ;;   (setq inferior-list-program "sbcl"))
#+END_SRC

** Haskell
For xmonad and beyond
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :init
    (add-hook 'haskell-mode-hook 'turn-on-haskell-indent))
#+END_SRC
** Javascript
*** Vanilla
=tern= and =tern-company= are for auto completion
#+BEGIN_SRC emacs-lisp
  (use-package tern
    :ensure t
    :init
    (setq tern-command '("/home/kevin/.node_modules/bin/tern")))

  (use-package company-tern
    :ensure t)
#+END_SRC

=js2= is a javascript 'ide'
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :init
    (add-to-list `auto-mode-alist '("\\.js\\'" . js2-mode))
    (setq js-indent-level 2)
    (add-hook 'js2-mode-hook
              (function (lambda ()
                          ;(js2-minor-mode t)
                          (setq evil-shift-width js-indent-level)
                          (smartparens-mode t)
                          (tern-mode t)))))
#+END_SRC
*** JSON
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :init
    (add-to-list `auto-mode-alist '("\\.json\\'" . json-mode)))
#+END_SRC
*** TypeScript
#+BEGIN_SRC emacs-lisp
  (use-package tide
    :ensure t
    :config
    ;; aligns annotation to the right hand side
    (setq company-tooltip-align-annotations t)
    ;; formats the buffer before saving
    (add-hook 'before-save-hook 'tide-format-before-save)
    (add-hook 'typescript-mode-hook
              (lambda ()
                (interactive)
                (tide-setup)
                (flycheck-mode +1)
                (setq flycheck-check-syntax-automatically '(save-mode-enabled))
                (eldoc-mode +1)
                (tide-hl-identifier-mode +1)))
    (add-hook 'tide-mode-hook
              (lambda ()
                (define-key tide-mode-map (kbd "<f12>") 'tide-jump-to-definition))))
#+END_SRC
*** React
=rjsx-mode= is for editing =.jsx= files
#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :ensure t)
#+END_SRC
** Web Mode
Set up web mode for html and css files
#+BEGIN_SRC emacs-lisp
  (use-package web-mode 
    :ensure t
    :init
    ;; (setq web-mode-ac-sources-alist
    ;;       '(("css" . (ac-source-css-property))
    ;;         ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (add-hook 'web-mode-before-auto-complete-hooks
              '(lambda ()
                 (let ((web-mode-cur-language
                        (web-mode-language-at-pos))))))
    (add-to-list `auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list `auto-mode-alist '("\\.css\\'" . web-mode))
    ;;(add-to-list `auto-mode-alist '("\\.js\\'" . web-mode))
    (add-hook 'web-mode-hook
              (lambda ()
                ; set the html indent to 2
                (setq web-mode-markup-indent-offset 2)
                (setq evil-shift-width 2)
                ; highlight matching elements in html
                (setq web-mode-enable-current-element-highlight 1))))
#+END_SRC

* Look and Feel
** Theme
Theme I'm currently using
#+BEGIN_SRC emacs-lisp
   (load-theme 'base16-tomorrow-night)
#+END_SRC

Some dark themes I Like
#+BEGIN_SRC emacs-lisp
  ;; (load-theme 'base16-spacemacs)
  ;;(load-theme 'gruvbox-dark-hard)
  ;;(load-theme 'sourcerer)
  ;;(load-theme 'spacemacs-dark)
  ;;(load-theme 'base16-tomorrow-dark)
  ;;(load-theme 'base16-twilight-dark)
  ;;(load-theme 'base16-default-dark)
  ;;(load-theme 'solarized-dark)
  ;;(setq solarized-distinct-fringe-background t)
  ;;(load-theme 'base16-ocean-dark)
  ;;(load-theme 'material)
  ;;(load-theme 'spacegray)
  ;;(load-theme 'dracula)

  ;;(load-theme 'reykjavik)
  ;;(set-cursor-color "gainsboro")
#+END_SRC

Some light themes I like
#+BEGIN_SRC emacs-lisp
  ;;(load-theme 'spacemacs-light)
  ;;(load-theme 'light-soap)
  ;;(load-theme 'solarized-light)
#+END_SRC
** Font
Font I'm currently using
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Hack-12" ))
#+END_SRC

Other fonts I like
=GohuFont= does not seem to play well with =org-bullets= sadly...
#+BEGIN_SRC emacs-lisp
  ;;(add-to-list 'default-frame-alist '(font . "Fira Code-12" ))
  ;;(add-to-list 'default-frame-alist '(font . "Hack-12" ))
  ;;(add-to-list 'default-frame-alist '(font . "Input Mono Narrow-11" ))
  ;;(add-to-list 'default-frame-alist '(font . "Hermit-10" ))
  ;;(add-to-list 'default-frame-alist '(font . "Monaco-10" ))
  ;;(add-to-list 'default-frame-alist '(font . "Fantasque Sans Mono-11" ))
  ;;(add-to-list 'default-frame-alist '(font . "GohuFont-14" ))
  ;;(add-to-list 'default-frame-alist '(font . "envypn-11" ))
#+END_SRC
** Other stuff
Hide the gui and use a non-blinking cursor for a more zen-like experience.
Use C-mouse3 to open the menu-bar as a popup menu
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -99)
  (tool-bar-mode -1) ;; hide the toolbar
  (scroll-bar-mode -1) ;; hide the scrollbar 
  (blink-cursor-mode 0) ;; dont blink the cursor
  (set-fringe-mode '(10 . 0)) ;;remove the extra border around frames
  (global-hl-line-mode 1) ;; highlight the current line
#+END_SRC

Add line numbers whenever the major mode is a programming language
#+BEGIN_SRC emacs-lisp 
  (add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

Add a space between the line numbers and the text
From https://www.emacswiki.org/emacs/LineNumbers
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'linum-before-numbering-hook
  ;;           (lambda ()
  ;;             (setq-local linum-format-fmt
  ;;                         (let ((w (length (number-to-string
  ;;                                           (count-lines (point-min) (point-max))))))
  ;;                           (concat "%" (number-to-string w) "d")))))

  ;; (defun linum-format-func (line)
  ;;   (concat
  ;;    (propertize (format linum-format-fmt line) 'face 'linum)
  ;;    (propertize " " 'face 'mode-line)))

  ;; (setq linum-format 'linum-format-func)
#+END_SRC
** Modeline
Add an animated nyan-cat to indicate the buffer position, because why not?
#+BEGIN_SRC emacs-lisp
  ;; (use-package nyan-mode
  ;;   :ensure t
  ;;   :init
  ;;   (setq nyan-wavy-trail t)
  ;;   :config
  ;;   (nyan-mode 1)
  ;;   (nyan-start-animation))
#+END_SRC

spacemacs modeline settings
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t)

  (use-package spaceline-config
    :ensure spaceline
    :config
    ;; (setq powerline-default-separator 'wave)
    ;; (setq powerline-default-separator 'alternate)
    ;; (setq powerline-default-separator 'arrow)
    ;; (setq powerline-default-separator 'arrow-fade)
    (setq powerline-default-separator 'bar)
    ;; (setq powerline-default-separator 'box)
    ;; (setq powerline-default-separator 'brace)
    ;; (setq powerline-default-separator 'butt)
    ;; (setq powerline-default-separator 'chamfer)
    ;; (setq powerline-default-separator 'contour)
    ;; (setq powerline-default-separator 'curve)
    ;; (setq powerline-default-separator 'rounded)
    ;; (setq powerline-default-separator 'roundstub)
    ;; (setq powerline-default-separator 'wave)
    ;; (setq powerline-default-separator 'zigzag)
    ;; (setq powerline-default-separator 'utf-8)

    (spaceline-spacemacs-theme)
    (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
    (setq spaceline-workspace-numbers-unicode t)
    (setq spaceline-window-numbers-unicode t))
#+END_SRC

My custom modeline
#+BEGIN_SRC emacs-lisp
  ;; (setq-default mode-line-format
  ;;               (list
  ;;      "-- " 
  ;;      ;; the buffer name; the file name as a tool tip
  ;;      '(:eval (propertize "%b " 'face 'font-lock-keyword-face
  ;;                         'help-echo (buffer-file-name)))

  ;;     ;; the current major mode for the buffer.
  ;;      "["

  ;;      '(:eval (propertize "%m" 'face 'font-lock-string-face
  ;;                          'help-echo buffer-file-coding-system))
  ;;      " -"
  ;;      minor-mode-alist ;; the minor modes for the current buffer
  ;;      "] "

  ;;      "[" ;; insert vs overwrite mode, input-method in a tooltip
  ;;      '(:eval (propertize (if overwrite-mode "Ovr" "Ins")
  ;;             'face 'font-lock-preprocessor-face
  ;;             'help-echo (concat "Buffer is in "
  ;;                             (if overwrite-mode "overwrite" "insert") " mode")))

  ;;      ;; was this buffer modified since the last save? 
  ;;      '(:eval (when (buffer-modified-p)
  ;;             (concat ","  (propertize "Mod"
  ;;             'face 'font-lock-warning-face
  ;;                               'help-echo "Buffer has been modified"))))

  ;;      ;; is this buffer read-only?
  ;;      '(:eval (when buffer-read-only
  ;;                (concat ","  (propertize "RO"
  ;;                               'face 'font-lock-type-face
  ;;                               'help-echo "Buffer is read-only"))))  
  ;;      "] "
      
  ;;      ;; line and column
  ;;      "(" ;; '%02' to set to 2 chars at least; prevents flickering
  ;;        (propertize "%02l" 'face 'font-lock-type-face) ","
  ;;        (propertize "%02c" 'face 'font-lock-type-face) 
  ;;      ") "

  ;;      '(:eval (list (nyan-create)))
      
  ;;      ;; relative position, size of file
  ;;      "["
  ;;      (propertize "%p" 'face 'font-lock-constant-face) ;; % above top
  ;;      ;;"/"
  ;;      ;;(propertize "%I" 'face 'font-lock-constant-face) ;; size
  ;;      "] "

  ;;      " %-" ;; fill with '-'
  ;;      ))
#+END_SRC

***** TODO make the color of the bar change when switching between evil modes
#+BEGIN_SRC emacs-lisp
  ;; change mode-line color by evil state
  ;;(lexical-let ((default-color (cons (face-background 'mode-line)
  ;;                                  (face-foreground 'mode-line))))
  ;;    (add-hook 'post-command-hook
  ;;    (lambda ()
  ;;      (let ((color (cond ((minibufferp) default-color)
  ;;                      ((evil-insert-state-p) '("#eee" . "#ffffff"))
  ;;                      ((evil-emacs-state-p)  '("#444488" . "#ffffff"))
  ;;                      ((buffer-modified-p)   '("#006fa0" . "#ffffff"))
  ;;                      (t default-color))))
  ;;      (set-face-background 'mode-line (car color))
  ;;      (set-face-foreground 'mode-line (cdr color))))))
#+END_SRC

